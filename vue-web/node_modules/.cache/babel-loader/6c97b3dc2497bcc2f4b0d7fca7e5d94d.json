{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\nimport omit from '../_util/omit';\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nvar AffixStatus;\n\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {})); // Affix\n\n\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      default: getDefaultTarget\n    },\n    prefixCls: String,\n\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  name: 'AAffix',\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n        emit = _ref.emit,\n        expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n\n    var measure = function measure() {\n      var status = state.status,\n          lastAffix = state.lastAffix;\n      var target = props.target;\n\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n\n      var targetNode = target();\n\n      if (!targetNode) {\n        return;\n      }\n\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      } // update state\n\n\n      _extends(state, newState);\n    };\n\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n\n      currentInstance.update(); // Test if `updatePosition` called\n\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle; // Check position change before measure to make Safari smooth\n\n      if (target && affixStyle) {\n        var targetNode = target();\n\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      } // Directly call prepare measure since it's already throttled.\n\n\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance); // Mock Event object.\n\n          updatePosition();\n        }\n\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance); // Mock Event object.\n\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel(); // https://github.com/ant-design/ant-design/issues/22683\n\n      lazyUpdatePosition.cancel();\n    });\n\n    var _useConfigInject = useConfigInject('affix', props),\n        prefixCls = _useConfigInject.prefixCls;\n\n    return function () {\n      var _a;\n\n      var affixStyle = state.affixStyle,\n          placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);","map":{"version":3,"names":["_objectSpread","_defineProperty","_extends","createVNode","_createVNode","defineComponent","ref","reactive","watch","onMounted","getCurrentInstance","computed","onUnmounted","onUpdated","classNames","ResizeObserver","throttleByAnimationFrame","withInstall","addObserveTarget","removeObserveTarget","getTargetRect","getFixedTop","getFixedBottom","useConfigInject","omit","getDefaultTarget","window","AffixStatus","affixProps","offsetTop","Number","offsetBottom","target","type","Function","default","prefixCls","String","onChange","onTestUpdatePosition","Affix","name","props","setup","_ref","slots","emit","expose","placeholderNode","fixedNode","state","affixStyle","undefined","placeholderStyle","status","None","lastAffix","prevTarget","timeout","currentInstance","measure","Prepare","value","targetNode","newState","targetRect","placeholderReact","fixedTop","fixedBottom","position","top","width","height","bottom","prepareMeasure","update","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","val","newTarget","setTimeout","clearTimeout","cancel","_useConfigInject","_a","className","restProps","_default","call"],"sources":["C:/Users/USTC/Desktop/community1/vue-web/node_modules/ant-design-vue/es/affix/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\nimport omit from '../_util/omit';\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nvar AffixStatus;\n\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {})); // Affix\n\n\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      default: getDefaultTarget\n    },\n    prefixCls: String,\n\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  name: 'AAffix',\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n        emit = _ref.emit,\n        expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n\n    var measure = function measure() {\n      var status = state.status,\n          lastAffix = state.lastAffix;\n      var target = props.target;\n\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n\n      var targetNode = target();\n\n      if (!targetNode) {\n        return;\n      }\n\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      } // update state\n\n\n      _extends(state, newState);\n    };\n\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n\n      currentInstance.update(); // Test if `updatePosition` called\n\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle; // Check position change before measure to make Safari smooth\n\n      if (target && affixStyle) {\n        var targetNode = target();\n\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      } // Directly call prepare measure since it's already throttled.\n\n\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance); // Mock Event object.\n\n          updatePosition();\n        }\n\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance); // Mock Event object.\n\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel(); // https://github.com/ant-design/ant-design/issues/22683\n\n      lazyUpdatePosition.cancel();\n    });\n\n    var _useConfigInject = useConfigInject('affix', props),\n        prefixCls = _useConfigInject.prefixCls;\n\n    return function () {\n      var _a;\n\n      var affixStyle = state.affixStyle,\n          placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);"],"mappings":"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"},"metadata":{},"sourceType":"module"}