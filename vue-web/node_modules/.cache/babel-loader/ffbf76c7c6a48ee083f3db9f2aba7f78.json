{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { createVNode as _createVNode } from \"vue\";\n/* eslint-disable no-lonely-if */\n\n/**\n * Legacy code. Should avoid to use if you are new to import these code.\n */\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport TreeNode from './TreeNode';\nimport { warning } from '../vc-util/warning';\nexport function arrDel(list, value) {\n  if (!list) return [];\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n\n  return clone;\n}\nexport function arrAdd(list, value) {\n  var clone = (list || []).slice();\n\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n\n  return clone;\n}\nexport function posToArr(pos) {\n  return pos.split('-');\n}\nexport function getPosition(level, index) {\n  return \"\".concat(level, \"-\").concat(index);\n}\nexport function isTreeNode(node) {\n  return node && node.type && node.type.isTreeNode;\n}\nexport function getDragChildrenKeys(dragNodeKey, keyEntities) {\n  // not contains self\n  // self for left or right drag\n  var dragChildrenKeys = [];\n  var entity = keyEntities[dragNodeKey];\n\n  function dig() {\n    var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    list.forEach(function (_ref) {\n      var key = _ref.key,\n          children = _ref.children;\n      dragChildrenKeys.push(key);\n      dig(children);\n    });\n  }\n\n  dig(entity.children);\n  return dragChildrenKeys;\n}\nexport function isLastChild(treeNodeEntity) {\n  if (treeNodeEntity.parent) {\n    var posArr = posToArr(treeNodeEntity.pos);\n    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;\n  }\n\n  return false;\n}\nexport function isFirstChild(treeNodeEntity) {\n  var posArr = posToArr(treeNodeEntity.pos);\n  return Number(posArr[posArr.length - 1]) === 0;\n} // Only used when drag, not affect SSR.\n\nexport function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeysSet, direction) {\n  var _a;\n\n  var clientX = event.clientX,\n      clientY = event.clientY;\n\n  var _event$target$getBoun = event.target.getBoundingClientRect(),\n      top = _event$target$getBoun.top,\n      height = _event$target$getBoun.height; // optional chain for testing\n\n\n  var horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);\n  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent; // find abstract drop node by horizontal offset\n\n  var abstractDropNodeEntity = keyEntities[targetNode.eventKey];\n\n  if (clientY < top + height / 2) {\n    // first half, set abstract drop node to previous node\n    var nodeIndex = flattenedNodes.findIndex(function (flattenedNode) {\n      return flattenedNode.key === abstractDropNodeEntity.key;\n    });\n    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;\n    var prevNodeKey = flattenedNodes[prevNodeIndex].key;\n    abstractDropNodeEntity = keyEntities[prevNodeKey];\n  }\n\n  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;\n  var abstractDragOverEntity = abstractDropNodeEntity;\n  var dragOverNodeKey = abstractDropNodeEntity.key;\n  var dropPosition = 0;\n  var dropLevelOffset = 0; // Only allow cross level drop when dragging on a non-expanded node\n\n  if (!expandKeysSet.has(initialAbstractDropNodeKey)) {\n    for (var i = 0; i < rawDropLevelOffset; i += 1) {\n      if (isLastChild(abstractDropNodeEntity)) {\n        abstractDropNodeEntity = abstractDropNodeEntity.parent;\n        dropLevelOffset += 1;\n      } else {\n        break;\n      }\n    }\n  }\n\n  var abstractDragDataNode = dragNode.eventData;\n  var abstractDropDataNode = abstractDropNodeEntity.node;\n  var dropAllowed = true;\n\n  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({\n    dragNode: abstractDragDataNode,\n    dropNode: abstractDropDataNode,\n    dropPosition: -1\n  }) && abstractDropNodeEntity.key === targetNode.eventKey) {\n    // first half of first node in first level\n    dropPosition = -1;\n  } else if ((abstractDragOverEntity.children || []).length && expandKeysSet.has(dragOverNodeKey)) {\n    // drop on expanded node\n    // only allow drop inside\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 0\n    })) {\n      dropPosition = 0;\n    } else {\n      dropAllowed = false;\n    }\n  } else if (dropLevelOffset === 0) {\n    if (rawDropLevelOffset > -1.5) {\n      // | Node     | <- abstractDropNode\n      // | -^-===== | <- mousePosition\n      // 1. try drop after\n      // 2. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    } else {\n      // | Node     | <- abstractDropNode\n      // | ---==^== | <- mousePosition\n      // whether it has children or doesn't has children\n      // always\n      // 1. try drop inside\n      // 2. try drop after\n      // 3. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 0\n      })) {\n        dropPosition = 0;\n      } else if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    }\n  } else {\n    // | Node1 | <- abstractDropNode\n    //      |  Node2  |\n    // --^--|----=====| <- mousePosition\n    // 1. try insert after Node1\n    // 2. do not allow drop\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 1\n    })) {\n      dropPosition = 1;\n    } else {\n      dropAllowed = false;\n    }\n  }\n\n  return {\n    dropPosition: dropPosition,\n    dropLevelOffset: dropLevelOffset,\n    dropTargetKey: abstractDropNodeEntity.key,\n    dropTargetPos: abstractDropNodeEntity.pos,\n    dragOverNodeKey: dragOverNodeKey,\n    dropContainerKey: dropPosition === 0 ? null : ((_a = abstractDropNodeEntity.parent) === null || _a === void 0 ? void 0 : _a.key) || null,\n    dropAllowed: dropAllowed\n  };\n}\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\n\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) return undefined;\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n\n  return selectedKeys;\n}\n\nvar internalProcessProps = function internalProcessProps(props) {\n  return props;\n};\n\nexport function convertDataToTree(treeData, processor) {\n  if (!treeData) return [];\n\n  var _ref2 = processor || {},\n      _ref2$processProps = _ref2.processProps,\n      processProps = _ref2$processProps === void 0 ? internalProcessProps : _ref2$processProps;\n\n  var list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(function (_a) {\n    var children = _a.children,\n        props = __rest(_a, [\"children\"]);\n\n    var childrenNodes = convertDataToTree(children, processor);\n    return _createVNode(TreeNode, _objectSpread({\n      \"key\": props.key\n    }, processProps(props)), {\n      default: function _default() {\n        return [childrenNodes];\n      }\n    });\n  });\n}\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\n\nexport function parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  } // Convert keys to object format\n\n\n  var keyProps;\n\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (_typeof(keys) === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n\n  return keyProps;\n}\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\n\nexport function conductExpandParent(keyList, keyEntities) {\n  var expandedKeys = new Set();\n\n  function conductUp(key) {\n    if (expandedKeys.has(key)) return;\n    var entity = keyEntities[key];\n    if (!entity) return;\n    expandedKeys.add(key);\n    var parent = entity.parent,\n        node = entity.node;\n    if (node.disabled) return;\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conductUp(key);\n  });\n  return _toConsumableArray(expandedKeys);\n}","map":{"version":3,"names":["_toConsumableArray","_typeof","_objectSpread","createVNode","_createVNode","__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","TreeNode","warning","arrDel","list","value","clone","slice","index","splice","arrAdd","push","posToArr","pos","split","getPosition","level","concat","isTreeNode","node","type","getDragChildrenKeys","dragNodeKey","keyEntities","dragChildrenKeys","entity","dig","arguments","undefined","forEach","_ref","key","children","isLastChild","treeNodeEntity","parent","posArr","Number","isFirstChild","calcDropPosition","event","dragNode","targetNode","indent","startMousePosition","allowDrop","flattenedNodes","expandKeysSet","direction","_a","clientX","clientY","_event$target$getBoun","target","getBoundingClientRect","top","height","horizontalMouseOffset","x","rawDropLevelOffset","abstractDropNodeEntity","eventKey","nodeIndex","findIndex","flattenedNode","prevNodeIndex","prevNodeKey","initialAbstractDropNodeKey","abstractDragOverEntity","dragOverNodeKey","dropPosition","dropLevelOffset","has","abstractDragDataNode","eventData","abstractDropDataNode","dropAllowed","dropNode","dropTargetKey","dropTargetPos","dropContainerKey","calcSelectedKeys","selectedKeys","props","multiple","internalProcessProps","convertDataToTree","treeData","processor","_ref2","_ref2$processProps","processProps","Array","isArray","map","childrenNodes","default","_default","parseCheckedKeys","keys","keyProps","checkedKeys","halfCheckedKeys","checked","halfChecked","conductExpandParent","keyList","expandedKeys","Set","conductUp","add","disabled"],"sources":["C:/Users/USTC/Desktop/community1/vue-web/node_modules/ant-design-vue/es/vc-tree/util.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { createVNode as _createVNode } from \"vue\";\n\n/* eslint-disable no-lonely-if */\n\n/**\n * Legacy code. Should avoid to use if you are new to import these code.\n */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport TreeNode from './TreeNode';\nimport { warning } from '../vc-util/warning';\nexport function arrDel(list, value) {\n  if (!list) return [];\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n\n  return clone;\n}\nexport function arrAdd(list, value) {\n  var clone = (list || []).slice();\n\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n\n  return clone;\n}\nexport function posToArr(pos) {\n  return pos.split('-');\n}\nexport function getPosition(level, index) {\n  return \"\".concat(level, \"-\").concat(index);\n}\nexport function isTreeNode(node) {\n  return node && node.type && node.type.isTreeNode;\n}\nexport function getDragChildrenKeys(dragNodeKey, keyEntities) {\n  // not contains self\n  // self for left or right drag\n  var dragChildrenKeys = [];\n  var entity = keyEntities[dragNodeKey];\n\n  function dig() {\n    var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    list.forEach(function (_ref) {\n      var key = _ref.key,\n          children = _ref.children;\n      dragChildrenKeys.push(key);\n      dig(children);\n    });\n  }\n\n  dig(entity.children);\n  return dragChildrenKeys;\n}\nexport function isLastChild(treeNodeEntity) {\n  if (treeNodeEntity.parent) {\n    var posArr = posToArr(treeNodeEntity.pos);\n    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;\n  }\n\n  return false;\n}\nexport function isFirstChild(treeNodeEntity) {\n  var posArr = posToArr(treeNodeEntity.pos);\n  return Number(posArr[posArr.length - 1]) === 0;\n} // Only used when drag, not affect SSR.\n\nexport function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeysSet, direction) {\n  var _a;\n\n  var clientX = event.clientX,\n      clientY = event.clientY;\n\n  var _event$target$getBoun = event.target.getBoundingClientRect(),\n      top = _event$target$getBoun.top,\n      height = _event$target$getBoun.height; // optional chain for testing\n\n\n  var horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);\n  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent; // find abstract drop node by horizontal offset\n\n  var abstractDropNodeEntity = keyEntities[targetNode.eventKey];\n\n  if (clientY < top + height / 2) {\n    // first half, set abstract drop node to previous node\n    var nodeIndex = flattenedNodes.findIndex(function (flattenedNode) {\n      return flattenedNode.key === abstractDropNodeEntity.key;\n    });\n    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;\n    var prevNodeKey = flattenedNodes[prevNodeIndex].key;\n    abstractDropNodeEntity = keyEntities[prevNodeKey];\n  }\n\n  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;\n  var abstractDragOverEntity = abstractDropNodeEntity;\n  var dragOverNodeKey = abstractDropNodeEntity.key;\n  var dropPosition = 0;\n  var dropLevelOffset = 0; // Only allow cross level drop when dragging on a non-expanded node\n\n  if (!expandKeysSet.has(initialAbstractDropNodeKey)) {\n    for (var i = 0; i < rawDropLevelOffset; i += 1) {\n      if (isLastChild(abstractDropNodeEntity)) {\n        abstractDropNodeEntity = abstractDropNodeEntity.parent;\n        dropLevelOffset += 1;\n      } else {\n        break;\n      }\n    }\n  }\n\n  var abstractDragDataNode = dragNode.eventData;\n  var abstractDropDataNode = abstractDropNodeEntity.node;\n  var dropAllowed = true;\n\n  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({\n    dragNode: abstractDragDataNode,\n    dropNode: abstractDropDataNode,\n    dropPosition: -1\n  }) && abstractDropNodeEntity.key === targetNode.eventKey) {\n    // first half of first node in first level\n    dropPosition = -1;\n  } else if ((abstractDragOverEntity.children || []).length && expandKeysSet.has(dragOverNodeKey)) {\n    // drop on expanded node\n    // only allow drop inside\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 0\n    })) {\n      dropPosition = 0;\n    } else {\n      dropAllowed = false;\n    }\n  } else if (dropLevelOffset === 0) {\n    if (rawDropLevelOffset > -1.5) {\n      // | Node     | <- abstractDropNode\n      // | -^-===== | <- mousePosition\n      // 1. try drop after\n      // 2. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    } else {\n      // | Node     | <- abstractDropNode\n      // | ---==^== | <- mousePosition\n      // whether it has children or doesn't has children\n      // always\n      // 1. try drop inside\n      // 2. try drop after\n      // 3. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 0\n      })) {\n        dropPosition = 0;\n      } else if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    }\n  } else {\n    // | Node1 | <- abstractDropNode\n    //      |  Node2  |\n    // --^--|----=====| <- mousePosition\n    // 1. try insert after Node1\n    // 2. do not allow drop\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 1\n    })) {\n      dropPosition = 1;\n    } else {\n      dropAllowed = false;\n    }\n  }\n\n  return {\n    dropPosition: dropPosition,\n    dropLevelOffset: dropLevelOffset,\n    dropTargetKey: abstractDropNodeEntity.key,\n    dropTargetPos: abstractDropNodeEntity.pos,\n    dragOverNodeKey: dragOverNodeKey,\n    dropContainerKey: dropPosition === 0 ? null : ((_a = abstractDropNodeEntity.parent) === null || _a === void 0 ? void 0 : _a.key) || null,\n    dropAllowed: dropAllowed\n  };\n}\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\n\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) return undefined;\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n\n  return selectedKeys;\n}\n\nvar internalProcessProps = function internalProcessProps(props) {\n  return props;\n};\n\nexport function convertDataToTree(treeData, processor) {\n  if (!treeData) return [];\n\n  var _ref2 = processor || {},\n      _ref2$processProps = _ref2.processProps,\n      processProps = _ref2$processProps === void 0 ? internalProcessProps : _ref2$processProps;\n\n  var list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(function (_a) {\n    var children = _a.children,\n        props = __rest(_a, [\"children\"]);\n\n    var childrenNodes = convertDataToTree(children, processor);\n    return _createVNode(TreeNode, _objectSpread({\n      \"key\": props.key\n    }, processProps(props)), {\n      default: function _default() {\n        return [childrenNodes];\n      }\n    });\n  });\n}\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\n\nexport function parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  } // Convert keys to object format\n\n\n  var keyProps;\n\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (_typeof(keys) === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n\n  return keyProps;\n}\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\n\nexport function conductExpandParent(keyList, keyEntities) {\n  var expandedKeys = new Set();\n\n  function conductUp(key) {\n    if (expandedKeys.has(key)) return;\n    var entity = keyEntities[key];\n    if (!entity) return;\n    expandedKeys.add(key);\n    var parent = entity.parent,\n        node = entity.node;\n    if (node.disabled) return;\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conductUp(key);\n  });\n  return _toConsumableArray(expandedKeys);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}