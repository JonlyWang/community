{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\nfunction e(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n  }\n}\n\nfunction t(t, n, r) {\n  return n && e(t.prototype, n), r && e(t, r), t;\n}\n\nfunction n() {\n  return (n = Object.assign || function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n\n    return e;\n  }).apply(this, arguments);\n}\n\nfunction r(e, t) {\n  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;\n}\n\nfunction i(e, t) {\n  if (null == e) return {};\n  var n,\n      r,\n      i = {},\n      o = Object.keys(e);\n\n  for (r = 0; r < o.length; r++) t.indexOf(n = o[r]) >= 0 || (i[n] = e[n]);\n\n  return i;\n}\n\nfunction o(e) {\n  return 1 == (null != (t = e) && \"object\" == typeof t && !1 === Array.isArray(t)) && \"[object Object]\" === Object.prototype.toString.call(e);\n  var t;\n}\n\nvar u = Object.prototype,\n    a = u.toString,\n    f = u.hasOwnProperty,\n    c = /^\\s*function (\\w+)/;\n\nfunction l(e) {\n  var t,\n      n = null !== (t = null == e ? void 0 : e.type) && void 0 !== t ? t : e;\n\n  if (n) {\n    var r = n.toString().match(c);\n    return r ? r[1] : \"\";\n  }\n\n  return \"\";\n}\n\nvar s = function (e) {\n  var t, n;\n  return !1 !== o(e) && \"function\" == typeof (t = e.constructor) && !1 !== o(n = t.prototype) && !1 !== n.hasOwnProperty(\"isPrototypeOf\");\n},\n    v = function (e) {\n  return e;\n},\n    y = v;\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var p = \"undefined\" != typeof console;\n  y = p ? function (e) {\n    console.warn(\"[VueTypes warn]: \" + e);\n  } : v;\n}\n\nvar d = function (e, t) {\n  return f.call(e, t);\n},\n    h = Number.isInteger || function (e) {\n  return \"number\" == typeof e && isFinite(e) && Math.floor(e) === e;\n},\n    b = Array.isArray || function (e) {\n  return \"[object Array]\" === a.call(e);\n},\n    O = function (e) {\n  return \"[object Function]\" === a.call(e);\n},\n    g = function (e) {\n  return s(e) && d(e, \"_vueTypes_name\");\n},\n    m = function (e) {\n  return s(e) && (d(e, \"type\") || [\"_vueTypes_name\", \"validator\", \"default\", \"required\"].some(function (t) {\n    return d(e, t);\n  }));\n};\n\nfunction j(e, t) {\n  return Object.defineProperty(e.bind(t), \"__original\", {\n    value: e\n  });\n}\n\nfunction _(e, t, n) {\n  var r;\n  void 0 === n && (n = !1);\n  var i = !0,\n      o = \"\";\n  r = s(e) ? e : {\n    type: e\n  };\n  var u = g(r) ? r._vueTypes_name + \" - \" : \"\";\n\n  if (m(r) && null !== r.type) {\n    if (void 0 === r.type || !0 === r.type) return i;\n    if (!r.required && void 0 === t) return i;\n    b(r.type) ? (i = r.type.some(function (e) {\n      return !0 === _(e, t, !0);\n    }), o = r.type.map(function (e) {\n      return l(e);\n    }).join(\" or \")) : i = \"Array\" === (o = l(r)) ? b(t) : \"Object\" === o ? s(t) : \"String\" === o || \"Number\" === o || \"Boolean\" === o || \"Function\" === o ? function (e) {\n      if (null == e) return \"\";\n      var t = e.constructor.toString().match(c);\n      return t ? t[1] : \"\";\n    }(t) === o : t instanceof r.type;\n  }\n\n  if (!i) {\n    var a = u + 'value \"' + t + '\" should be of type \"' + o + '\"';\n    return !1 === n ? (y(a), !1) : a;\n  }\n\n  if (d(r, \"validator\") && O(r.validator)) {\n    var f = y,\n        v = [];\n\n    if (y = function (e) {\n      v.push(e);\n    }, i = r.validator(t), y = f, !i) {\n      var p = (v.length > 1 ? \"* \" : \"\") + v.join(\"\\n* \");\n      return v.length = 0, !1 === n ? (y(p), i) : p;\n    }\n  }\n\n  return i;\n}\n\nfunction T(e, t) {\n  var n = Object.defineProperties(t, {\n    _vueTypes_name: {\n      value: e,\n      writable: !0\n    },\n    isRequired: {\n      get: function () {\n        return this.required = !0, this;\n      }\n    },\n    def: {\n      value: function (e) {\n        return void 0 !== e || this.default ? O(e) || !0 === _(this, e, !0) ? (this.default = b(e) ? function () {\n          return [].concat(e);\n        } : s(e) ? function () {\n          return Object.assign({}, e);\n        } : e, this) : (y(this._vueTypes_name + ' - invalid default value: \"' + e + '\"'), this) : this;\n      }\n    }\n  }),\n      r = n.validator;\n  return O(r) && (n.validator = j(r, n)), n;\n}\n\nfunction w(e, t) {\n  var n = T(e, t);\n  return Object.defineProperty(n, \"validate\", {\n    value: function (e) {\n      return O(this.validator) && y(this._vueTypes_name + \" - calling .validate() will overwrite the current custom validator function. Validator info:\\n\" + JSON.stringify(this)), this.validator = j(e, this), this;\n    }\n  });\n}\n\nfunction k(e, t, n) {\n  var r,\n      o,\n      u = (r = t, o = {}, Object.getOwnPropertyNames(r).forEach(function (e) {\n    o[e] = Object.getOwnPropertyDescriptor(r, e);\n  }), Object.defineProperties({}, o));\n  if (u._vueTypes_name = e, !s(n)) return u;\n  var a,\n      f,\n      c = n.validator,\n      l = i(n, [\"validator\"]);\n\n  if (O(c)) {\n    var v = u.validator;\n    v && (v = null !== (f = (a = v).__original) && void 0 !== f ? f : a), u.validator = j(v ? function (e) {\n      return v.call(this, e) && c.call(this, e);\n    } : c, u);\n  }\n\n  return Object.assign(u, l);\n}\n\nfunction P(e) {\n  return e.replace(/^(?!\\s*$)/gm, \"  \");\n}\n\nvar x = function () {\n  return w(\"any\", {});\n},\n    A = function () {\n  return w(\"function\", {\n    type: Function\n  });\n},\n    E = function () {\n  return w(\"boolean\", {\n    type: Boolean\n  });\n},\n    N = function () {\n  return w(\"string\", {\n    type: String\n  });\n},\n    q = function () {\n  return w(\"number\", {\n    type: Number\n  });\n},\n    S = function () {\n  return w(\"array\", {\n    type: Array\n  });\n},\n    V = function () {\n  return w(\"object\", {\n    type: Object\n  });\n},\n    F = function () {\n  return T(\"integer\", {\n    type: Number,\n    validator: function (e) {\n      return h(e);\n    }\n  });\n},\n    D = function () {\n  return T(\"symbol\", {\n    validator: function (e) {\n      return \"symbol\" == typeof e;\n    }\n  });\n};\n\nfunction L(e, t) {\n  if (void 0 === t && (t = \"custom validation failed\"), \"function\" != typeof e) throw new TypeError(\"[VueTypes error]: You must provide a function as argument\");\n  return T(e.name || \"<<anonymous function>>\", {\n    validator: function (n) {\n      var r = e(n);\n      return r || y(this._vueTypes_name + \" - \" + t), r;\n    }\n  });\n}\n\nfunction Y(e) {\n  if (!b(e)) throw new TypeError(\"[VueTypes error]: You must provide an array as argument.\");\n  var t = 'oneOf - value should be one of \"' + e.join('\", \"') + '\".',\n      n = e.reduce(function (e, t) {\n    if (null != t) {\n      var n = t.constructor;\n      -1 === e.indexOf(n) && e.push(n);\n    }\n\n    return e;\n  }, []);\n  return T(\"oneOf\", {\n    type: n.length > 0 ? n : void 0,\n    validator: function (n) {\n      var r = -1 !== e.indexOf(n);\n      return r || y(t), r;\n    }\n  });\n}\n\nfunction B(e) {\n  if (!b(e)) throw new TypeError(\"[VueTypes error]: You must provide an array as argument\");\n\n  for (var t = !1, n = [], r = 0; r < e.length; r += 1) {\n    var i = e[r];\n\n    if (m(i)) {\n      if (g(i) && \"oneOf\" === i._vueTypes_name) {\n        n = n.concat(i.type);\n        continue;\n      }\n\n      if (O(i.validator) && (t = !0), !0 !== i.type && i.type) {\n        n = n.concat(i.type);\n        continue;\n      }\n    }\n\n    n.push(i);\n  }\n\n  return n = n.filter(function (e, t) {\n    return n.indexOf(e) === t;\n  }), T(\"oneOfType\", t ? {\n    type: n,\n    validator: function (t) {\n      var n = [],\n          r = e.some(function (e) {\n        var r = _(g(e) && \"oneOf\" === e._vueTypes_name ? e.type || null : e, t, !0);\n\n        return \"string\" == typeof r && n.push(r), !0 === r;\n      });\n      return r || y(\"oneOfType - provided value does not match any of the \" + n.length + \" passed-in validators:\\n\" + P(n.join(\"\\n\"))), r;\n    }\n  } : {\n    type: n\n  });\n}\n\nfunction I(e) {\n  return T(\"arrayOf\", {\n    type: Array,\n    validator: function (t) {\n      var n,\n          r = t.every(function (t) {\n        return !0 === (n = _(e, t, !0));\n      });\n      return r || y(\"arrayOf - value validation error:\\n\" + P(n)), r;\n    }\n  });\n}\n\nfunction J(e) {\n  return T(\"instanceOf\", {\n    type: e\n  });\n}\n\nfunction M(e) {\n  return T(\"objectOf\", {\n    type: Object,\n    validator: function (t) {\n      var n,\n          r = Object.keys(t).every(function (r) {\n        return !0 === (n = _(e, t[r], !0));\n      });\n      return r || y(\"objectOf - value validation error:\\n\" + P(n)), r;\n    }\n  });\n}\n\nfunction R(e) {\n  var t = Object.keys(e),\n      n = t.filter(function (t) {\n    var n;\n    return !!(null === (n = e[t]) || void 0 === n ? void 0 : n.required);\n  }),\n      r = T(\"shape\", {\n    type: Object,\n    validator: function (r) {\n      var i = this;\n      if (!s(r)) return !1;\n      var o = Object.keys(r);\n\n      if (n.length > 0 && n.some(function (e) {\n        return -1 === o.indexOf(e);\n      })) {\n        var u = n.filter(function (e) {\n          return -1 === o.indexOf(e);\n        });\n        return y(1 === u.length ? 'shape - required property \"' + u[0] + '\" is not defined.' : 'shape - required properties \"' + u.join('\", \"') + '\" are not defined.'), !1;\n      }\n\n      return o.every(function (n) {\n        if (-1 === t.indexOf(n)) return !0 === i._vueTypes_isLoose || (y('shape - shape definition does not include a \"' + n + '\" property. Allowed keys: \"' + t.join('\", \"') + '\".'), !1);\n\n        var o = _(e[n], r[n], !0);\n\n        return \"string\" == typeof o && y('shape - \"' + n + '\" property validation error:\\n ' + P(o)), !0 === o;\n      });\n    }\n  });\n  return Object.defineProperty(r, \"_vueTypes_isLoose\", {\n    writable: !0,\n    value: !1\n  }), Object.defineProperty(r, \"loose\", {\n    get: function () {\n      return this._vueTypes_isLoose = !0, this;\n    }\n  }), r;\n}\n\nvar $ = function () {\n  function e() {}\n\n  return e.extend = function (e) {\n    var t = this;\n    if (b(e)) return e.forEach(function (e) {\n      return t.extend(e);\n    }), this;\n    var n = e.name,\n        r = e.validate,\n        o = void 0 !== r && r,\n        u = e.getter,\n        a = void 0 !== u && u,\n        f = i(e, [\"name\", \"validate\", \"getter\"]);\n    if (d(this, n)) throw new TypeError('[VueTypes error]: Type \"' + n + '\" already defined');\n    var c,\n        l = f.type;\n    return g(l) ? (delete f.type, Object.defineProperty(this, n, a ? {\n      get: function () {\n        return k(n, l, f);\n      }\n    } : {\n      value: function () {\n        var e,\n            t = k(n, l, f);\n        return t.validator && (t.validator = (e = t.validator).bind.apply(e, [t].concat([].slice.call(arguments)))), t;\n      }\n    })) : (c = a ? {\n      get: function () {\n        var e = Object.assign({}, f);\n        return o ? w(n, e) : T(n, e);\n      },\n      enumerable: !0\n    } : {\n      value: function () {\n        var e,\n            t,\n            r = Object.assign({}, f);\n        return e = o ? w(n, r) : T(n, r), r.validator && (e.validator = (t = r.validator).bind.apply(t, [e].concat([].slice.call(arguments)))), e;\n      },\n      enumerable: !0\n    }, Object.defineProperty(this, n, c));\n  }, t(e, null, [{\n    key: \"any\",\n    get: function () {\n      return x();\n    }\n  }, {\n    key: \"func\",\n    get: function () {\n      return A().def(this.defaults.func);\n    }\n  }, {\n    key: \"bool\",\n    get: function () {\n      return E().def(this.defaults.bool);\n    }\n  }, {\n    key: \"string\",\n    get: function () {\n      return N().def(this.defaults.string);\n    }\n  }, {\n    key: \"number\",\n    get: function () {\n      return q().def(this.defaults.number);\n    }\n  }, {\n    key: \"array\",\n    get: function () {\n      return S().def(this.defaults.array);\n    }\n  }, {\n    key: \"object\",\n    get: function () {\n      return V().def(this.defaults.object);\n    }\n  }, {\n    key: \"integer\",\n    get: function () {\n      return F().def(this.defaults.integer);\n    }\n  }, {\n    key: \"symbol\",\n    get: function () {\n      return D();\n    }\n  }]), e;\n}();\n\nfunction z(e) {\n  var i;\n  return void 0 === e && (e = {\n    func: function () {},\n    bool: !0,\n    string: \"\",\n    number: 0,\n    array: function () {\n      return [];\n    },\n    object: function () {\n      return {};\n    },\n    integer: 0\n  }), (i = function (i) {\n    function o() {\n      return i.apply(this, arguments) || this;\n    }\n\n    return r(o, i), t(o, null, [{\n      key: \"sensibleDefaults\",\n      get: function () {\n        return n({}, this.defaults);\n      },\n      set: function (t) {\n        this.defaults = !1 !== t ? n({}, !0 !== t ? t : e) : {};\n      }\n    }]), o;\n  }($)).defaults = n({}, e), i;\n}\n\n$.defaults = {}, $.custom = L, $.oneOf = Y, $.instanceOf = J, $.oneOfType = B, $.arrayOf = I, $.objectOf = M, $.shape = R, $.utils = {\n  validate: function (e, t) {\n    return !0 === _(t, e, !0);\n  },\n  toType: function (e, t, n) {\n    return void 0 === n && (n = !1), n ? w(e, t) : T(e, t);\n  }\n};\n\nvar C = function (e) {\n  function t() {\n    return e.apply(this, arguments) || this;\n  }\n\n  return r(t, e), t;\n}(z());\n\nexport default C;\nexport { x as any, S as array, I as arrayOf, E as bool, z as createTypes, L as custom, k as fromType, A as func, J as instanceOf, F as integer, q as number, V as object, M as objectOf, Y as oneOf, B as oneOfType, R as shape, N as string, D as symbol, T as toType, w as toValidableType, _ as validateType };","map":{"version":3,"mappings":"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","names":["isObjectObject","o","val","Array","isArray","Object","prototype","toString","call","ObjProto","hasOwn","hasOwnProperty","FN_MATCH_REGEXP","getType","fn","type","match","isPlainObject","ctor","prot","constructor","identity","arg","warn","process","env","NODE_ENV","hasConsole","console","msg","has","obj","prop","isInteger","Number","value","isFinite","Math","floor","isFunction","isVueTypeDef","isComplexType","some","k","bindTo","ctx","defineProperty","bind","validateType","silent","typeToCheck","valid","expectedType","namePrefix","_vueTypes_name","undefined","required","map","join","getNativeType","validator","oldWarn","warnLog","push","length","toType","name","defineProperties","writable","isRequired","get","this","def","default","assign","toValidableType","JSON","stringify","fromType","source","props","descriptors","copy","getOwnPropertyNames","forEach","key","getOwnPropertyDescriptor","rest","prevValidator","__original","indent","string","replace","any","func","Function","bool","Boolean","String","number","array","object","integer","symbol","custom","validatorFn","warnMsg","TypeError","oneOf","arr","allowedTypes","reduce","ret","v","constr","indexOf","oneOfType","hasCustomValidators","nativeChecks","i","concat","filter","t","err","res","arrayOf","values","vResult","every","instanceOf","instanceConstructor","objectOf","keys","shape","requiredKeys","_obj$key","valueKeys","req","missing","_this","_vueTypes_isLoose","BaseVueTypes","extend","p","validate","getter","opts","descriptor","typeOptions","enumerable","defaults","createTypes","defs","validable","VueTypes"],"sources":["../node_modules/is-plain-object/index.es.js","../src/utils.ts","../src/validators/native.ts","../src/validators/custom.ts","../src/validators/oneof.ts","../src/validators/oneoftype.ts","../src/validators/arrayof.ts","../src/validators/instanceof.ts","../src/validators/objectof.ts","../src/validators/shape.ts","../src/index.ts","../src/sensibles.ts"],"sourcesContent":["/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n}\n\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport default isPlainObject;\n","import _isPlainObject from 'is-plain-object'\nimport {\n  VueTypeDef,\n  VueTypeValidableDef,\n  VueProp,\n  InferType,\n  PropOptions,\n} from './types'\n\nconst ObjProto = Object.prototype\nconst toString = ObjProto.toString\nexport const hasOwn = ObjProto.hasOwnProperty\n\nconst FN_MATCH_REGEXP = /^\\s*function (\\w+)/\n\n// https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L177\nexport function getType(\n  fn: VueProp<any> | (() => any) | (new (...args: any[]) => any),\n): string {\n  const type = (fn as VueProp<any>)?.type ?? fn\n  if (type) {\n    const match = type.toString().match(FN_MATCH_REGEXP)\n    return match ? match[1] : ''\n  }\n  return ''\n}\n\nexport function getNativeType(value: any): string {\n  if (value === null || value === undefined) return ''\n  const match = value.constructor.toString().match(FN_MATCH_REGEXP)\n  return match ? match[1] : ''\n}\n\ntype PlainObject = { [key: string]: any }\nexport const isPlainObject = _isPlainObject as (obj: any) => obj is PlainObject\n\n/**\n * No-op function\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\n/**\n * A function that returns its first argument\n *\n * @param arg - Any argument\n */\nexport const identity = (arg: any) => arg\n\nlet warn: (msg: string) => string | void = identity\n\nif (process.env.NODE_ENV !== 'production') {\n  const hasConsole = typeof console !== 'undefined'\n  warn = hasConsole\n    ? function warn(msg) {\n        // eslint-disable-next-line no-console\n        console.warn(`[VueTypes warn]: ${msg}`)\n      }\n    : identity\n}\n\nexport { warn }\n\n/**\n * Checks for a own property in an object\n *\n * @param {object} obj - Object\n * @param {string} prop - Property to check\n */\nexport const has = <T extends any, U extends keyof T>(obj: T, prop: U) =>\n  hasOwn.call(obj, prop)\n\n/**\n * Determines whether the passed value is an integer. Uses `Number.isInteger` if available\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @param {*} value - The value to be tested for being an integer.\n * @returns {boolean}\n */\nexport const isInteger =\n  Number.isInteger ||\n  function isInteger(value: unknown): value is number {\n    return (\n      typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value\n    )\n  }\n\n/**\n * Determines whether the passed value is an Array.\n *\n * @param {*} value - The value to be tested for being an array.\n * @returns {boolean}\n */\nexport const isArray =\n  Array.isArray ||\n  function isArray(value): value is any[] {\n    return toString.call(value) === '[object Array]'\n  }\n\n/**\n * Checks if a value is a function\n *\n * @param {any} value - Value to check\n * @returns {boolean}\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = (value: unknown): value is Function =>\n  toString.call(value) === '[object Function]'\n\n/**\n * Checks if the passed-in value is a VueTypes type\n * @param value - The value to check\n */\nexport const isVueTypeDef = <T>(\n  value: any,\n): value is VueTypeDef<T> | VueTypeValidableDef<T> =>\n  isPlainObject(value) && has(value, '_vueTypes_name')\n\n/**\n * Checks if the passed-in value is a Vue prop definition object or a VueTypes type\n * @param value - The value to check\n */\nexport const isComplexType = <T>(value: any): value is VueProp<T> =>\n  isPlainObject(value) &&\n  (has(value, 'type') ||\n    ['_vueTypes_name', 'validator', 'default', 'required'].some((k) =>\n      has(value, k),\n    ))\n\nexport interface WrappedFn {\n  (...args: any[]): any\n  __original: (...args: any[]) => any\n}\n\n/**\n * Binds a function to a context and saves a reference to the original.\n *\n * @param fn - Target function\n * @param ctx - New function context\n */\nexport function bindTo(fn: (...args: any[]) => any, ctx: any): WrappedFn {\n  return Object.defineProperty(fn.bind(ctx), '__original', {\n    value: fn,\n  })\n}\n\n/**\n * Returns the original function bounded with `bindTo`. If the passed-in function\n * has not be bound, the function itself will be returned instead.\n *\n * @param fn - Function to unwrap\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function unwrap<T extends WrappedFn | Function>(fn: T) {\n  return (fn as WrappedFn).__original ?? fn\n}\n\n/**\n * Validates a given value against a prop type object.\n *\n * If `silent` is `false` (default) will return a boolean. If it is set to `true`\n * it will return `true` on success or a string error message on failure\n *\n * @param {Object|*} type - Type to use for validation. Either a type object or a constructor\n * @param {*} value - Value to check\n * @param {boolean} silent - Silence warnings\n */\nexport function validateType<T, U>(\n  type: T,\n  value: U,\n  silent = false,\n): string | boolean {\n  let typeToCheck: { [key: string]: any }\n  let valid = true\n  let expectedType = ''\n  if (!isPlainObject(type)) {\n    typeToCheck = { type }\n  } else {\n    typeToCheck = type\n  }\n  const namePrefix = isVueTypeDef(typeToCheck)\n    ? typeToCheck._vueTypes_name + ' - '\n    : ''\n\n  if (isComplexType(typeToCheck) && typeToCheck.type !== null) {\n    if (typeToCheck.type === undefined || typeToCheck.type === true) {\n      return valid\n    }\n    if (!typeToCheck.required && value === undefined) {\n      return valid\n    }\n    if (isArray(typeToCheck.type)) {\n      valid = typeToCheck.type.some(\n        (type: any) => validateType(type, value, true) === true,\n      )\n      expectedType = typeToCheck.type\n        .map((type: any) => getType(type))\n        .join(' or ')\n    } else {\n      expectedType = getType(typeToCheck)\n\n      if (expectedType === 'Array') {\n        valid = isArray(value)\n      } else if (expectedType === 'Object') {\n        valid = isPlainObject(value)\n      } else if (\n        expectedType === 'String' ||\n        expectedType === 'Number' ||\n        expectedType === 'Boolean' ||\n        expectedType === 'Function'\n      ) {\n        valid = getNativeType(value) === expectedType\n      } else {\n        valid = value instanceof typeToCheck.type\n      }\n    }\n  }\n\n  if (!valid) {\n    const msg = `${namePrefix}value \"${value}\" should be of type \"${expectedType}\"`\n    if (silent === false) {\n      warn(msg)\n      return false\n    }\n    return msg\n  }\n\n  if (has(typeToCheck, 'validator') && isFunction(typeToCheck.validator)) {\n    const oldWarn = warn\n    const warnLog = []\n    warn = (msg) => {\n      warnLog.push(msg)\n    }\n\n    valid = typeToCheck.validator(value)\n    warn = oldWarn\n\n    if (!valid) {\n      const msg = (warnLog.length > 1 ? '* ' : '') + warnLog.join('\\n* ')\n      warnLog.length = 0\n      if (silent === false) {\n        warn(msg)\n        return valid\n      }\n      return msg\n    }\n  }\n  return valid\n}\n\n/**\n * Adds `isRequired` and `def` modifiers to an object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toType<T = any>(name: string, obj: PropOptions<T>) {\n  const type: VueTypeDef<T> = Object.defineProperties(obj, {\n    _vueTypes_name: {\n      value: name,\n      writable: true,\n    },\n    isRequired: {\n      get() {\n        this.required = true\n        return this\n      },\n    },\n    def: {\n      value(def?: any) {\n        if (def === undefined && !this.default) {\n          return this\n        }\n        if (!isFunction(def) && validateType(this, def, true) !== true) {\n          warn(`${this._vueTypes_name} - invalid default value: \"${def}\"`)\n          return this\n        }\n        if (isArray(def)) {\n          this.default = () => [...def]\n        } else if (isPlainObject(def)) {\n          this.default = () => Object.assign({}, def)\n        } else {\n          this.default = def\n        }\n        return this\n      },\n    },\n  })\n\n  const { validator } = type\n  if (isFunction(validator)) {\n    type.validator = bindTo(validator, type)\n  }\n\n  return type\n}\n\n/**\n * Like `toType` but also adds the `validate()` method to the type object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toValidableType<T = any>(name: string, obj: PropOptions<T>) {\n  const type = toType<T>(name, obj)\n  return Object.defineProperty(type, 'validate', {\n    value(fn: (value: T) => boolean) {\n      if (isFunction(this.validator)) {\n        warn(\n          `${\n            this._vueTypes_name\n          } - calling .validate() will overwrite the current custom validator function. Validator info:\\n${JSON.stringify(\n            this,\n          )}`,\n        )\n      }\n      this.validator = bindTo(fn, this)\n      return this\n    },\n  }) as VueTypeValidableDef<T>\n}\n\n/**\n *  Clones an object preserving all of it's own keys.\n *\n * @param obj - Object to clone\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function clone<T extends object>(obj: T): T {\n  const descriptors = {} as { [P in keyof T]: any }\n  Object.getOwnPropertyNames(obj).forEach((key) => {\n    descriptors[key as keyof T] = Object.getOwnPropertyDescriptor(obj, key)\n  })\n  return Object.defineProperties({}, descriptors)\n}\n\n/**\n * Return a new VueTypes type using another type as base.\n *\n * Properties in the `props` object will overwrite those defined in the source one\n * expect for the `validator` function. In that case both functions will be executed in series.\n *\n * @param name - Name of the new type\n * @param source - Source type\n * @param props - Custom type properties\n */\nexport function fromType<T extends VueTypeDef<any>>(name: string, source: T): T\nexport function fromType<\n  T extends VueTypeDef<any>,\n  V extends PropOptions<InferType<T>>\n>(name: string, source: T, props: V): Omit<T, keyof V> & V\nexport function fromType<\n  T extends VueTypeDef<any>,\n  V extends PropOptions<InferType<T>>\n>(name: string, source: T, props?: V) {\n  // 1. create an exact copy of the source type\n  const copy = clone(source)\n\n  // 2. give it a new name\n  copy._vueTypes_name = name\n\n  if (!isPlainObject(props)) {\n    return copy\n  }\n  const { validator, ...rest } = props\n\n  // 3. compose the validator function\n  // with the one on the source (if present)\n  // and ensure it is bound to the copy\n  if (isFunction(validator)) {\n    let { validator: prevValidator } = copy\n\n    if (prevValidator) {\n      prevValidator = unwrap(prevValidator)\n    }\n\n    copy.validator = bindTo(\n      prevValidator\n        ? function (this: T, value: any) {\n            return (\n              prevValidator.call(this, value) && validator.call(this, value)\n            )\n          }\n        : validator,\n      copy,\n    )\n  }\n  // 4. overwrite the rest, if present\n  return Object.assign(copy, rest as V)\n}\n\nexport function indent(string: string) {\n  return string.replace(/^(?!\\s*$)/gm, '  ')\n}\n","import { toType, toValidableType, isInteger } from '../utils'\nimport { PropType } from '../types'\n\nexport const any = () => toValidableType('any', {})\n\nexport const func = <T extends (...args: any[]) => any>() =>\n  toValidableType<T>('function', {\n    type: Function as PropType<T>,\n  })\n\nexport const bool = () =>\n  toValidableType('boolean', {\n    type: Boolean,\n  })\n\nexport const string = () =>\n  toValidableType('string', {\n    type: String,\n  })\n\nexport const number = () =>\n  toValidableType('number', {\n    type: Number,\n  })\n\nexport const array = <T>() =>\n  toValidableType<T[]>('array', {\n    type: Array,\n  })\n\nexport const object = <T extends { [key: string]: any }>() =>\n  toValidableType<T>('object', {\n    type: Object,\n  })\n\nexport const integer = () =>\n  toType('integer', {\n    type: Number,\n    validator(value) {\n      return isInteger(value)\n    },\n  })\n\nexport const symbol = () =>\n  toType<symbol>('symbol', {\n    validator(value) {\n      return typeof value === 'symbol'\n    },\n  })\n","import { toType, warn } from '../utils'\nimport { ValidatorFunction, VueTypeDef } from '../types'\n\nexport default function custom<T>(\n  validatorFn: ValidatorFunction<T>,\n  warnMsg = 'custom validation failed',\n) {\n  if (typeof validatorFn !== 'function') {\n    throw new TypeError(\n      '[VueTypes error]: You must provide a function as argument',\n    )\n  }\n\n  return toType<T>(validatorFn.name || '<<anonymous function>>', {\n    validator(this: VueTypeDef<T>, value: T) {\n      const valid = validatorFn(value)\n      if (!valid) warn(`${this._vueTypes_name} - ${warnMsg}`)\n      return valid\n    },\n  })\n}\n","import { Prop } from '../types'\nimport { toType, warn, isArray } from '../utils'\n\nexport default function oneOf<T extends readonly any[]>(arr: T) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument.',\n    )\n  }\n  const msg = `oneOf - value should be one of \"${arr.join('\", \"')}\".`\n  const allowedTypes = arr.reduce((ret, v) => {\n    if (v !== null && v !== undefined) {\n      const constr = (v as any).constructor\n      ret.indexOf(constr) === -1 && ret.push(constr)\n    }\n    return ret\n  }, [] as Prop<T[number]>[])\n\n  return toType<T[number]>('oneOf', {\n    type: allowedTypes.length > 0 ? allowedTypes : undefined,\n    validator(value) {\n      const valid = arr.indexOf(value) !== -1\n      if (!valid) warn(msg)\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, InferType, PropType } from '../types'\nimport {\n  isArray,\n  isComplexType,\n  isVueTypeDef,\n  isFunction,\n  toType,\n  validateType,\n  warn,\n  indent,\n} from '../utils'\n\nexport default function oneOfType<\n  U extends VueProp<any> | Prop<any>,\n  V = InferType<U>\n>(arr: U[]) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument',\n    )\n  }\n\n  let hasCustomValidators = false\n\n  let nativeChecks: Prop<V>[] = []\n\n  for (let i = 0; i < arr.length; i += 1) {\n    const type = arr[i]\n    if (isComplexType<V>(type)) {\n      if (isVueTypeDef<V>(type) && type._vueTypes_name === 'oneOf') {\n        nativeChecks = nativeChecks.concat(type.type as PropType<V>)\n        continue\n      }\n      if (isFunction(type.validator)) {\n        hasCustomValidators = true\n      }\n      if (type.type !== true && type.type) {\n        nativeChecks = nativeChecks.concat(type.type)\n        continue\n      }\n    }\n    nativeChecks.push(type as Prop<V>)\n  }\n\n  // filter duplicates\n  nativeChecks = nativeChecks.filter((t, i) => nativeChecks.indexOf(t) === i)\n\n  if (!hasCustomValidators) {\n    // we got just native objects (ie: Array, Object)\n    // delegate to Vue native prop check\n    return toType<V>('oneOfType', {\n      type: nativeChecks,\n    })\n  }\n\n  return toType<V>('oneOfType', {\n    type: nativeChecks,\n    validator(value) {\n      const err: string[] = []\n      const valid = arr.some((type) => {\n        const t =\n          isVueTypeDef(type) && type._vueTypes_name === 'oneOf'\n            ? type.type || null\n            : type\n        const res = validateType(t, value, true)\n        if (typeof res === 'string') {\n          err.push(res)\n        }\n        return res === true\n      })\n      if (!valid) {\n        warn(\n          `oneOfType - provided value does not match any of the ${\n            err.length\n          } passed-in validators:\\n${indent(err.join('\\n'))}`,\n        )\n      }\n\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, InferType } from '../types'\nimport { toType, validateType, warn, indent } from '../utils'\n\nexport default function arrayOf<T extends VueProp<any> | Prop<any>>(type: T) {\n  return toType<InferType<T>[]>('arrayOf', {\n    type: Array,\n    validator(values: any[]) {\n      let vResult: string | boolean\n      const valid = values.every((value) => {\n        vResult = validateType(type, value, true)\n        return vResult === true\n      })\n      if (!valid) {\n        warn(`arrayOf - value validation error:\\n${indent(vResult as string)}`)\n      }\n      return valid\n    },\n  })\n}\n","import { toType } from '../utils'\nimport { Constructor } from '../types'\n\nexport default function instanceOf<C extends Constructor>(\n  instanceConstructor: C,\n) {\n  return toType<InstanceType<C>>('instanceOf', {\n    type: instanceConstructor,\n  })\n}\n","import { Prop, VueProp, InferType } from '../types'\nimport { toType, validateType, warn, indent } from '../utils'\n\nexport default function objectOf<T extends VueProp<any> | Prop<any>>(type: T) {\n  return toType<{ [key: string]: InferType<T> }>('objectOf', {\n    type: Object,\n    validator(obj) {\n      let vResult: string | boolean\n      const valid = Object.keys(obj).every((key) => {\n        vResult = validateType(type, obj[key], true)\n        return vResult === true\n      })\n\n      if (!valid) {\n        warn(`objectOf - value validation error:\\n${indent(vResult as string)}`)\n      }\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, VueTypeShape, VueTypeLooseShape } from '../types'\nimport { toType, validateType, warn, isPlainObject, indent } from '../utils'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default function shape<T extends object>(\n  obj: { [K in keyof T]: Prop<T[K]> | VueProp<T[K]> },\n): VueTypeShape<T> {\n  const keys = Object.keys(obj)\n  const requiredKeys = keys.filter((key) => !!(obj as any)[key]?.required)\n\n  const type = toType('shape', {\n    type: Object,\n    validator(this: VueTypeShape<T> | VueTypeLooseShape<T>, value) {\n      if (!isPlainObject(value)) {\n        return false\n      }\n      const valueKeys = Object.keys(value)\n\n      // check for required keys (if any)\n      if (\n        requiredKeys.length > 0 &&\n        requiredKeys.some((req) => valueKeys.indexOf(req) === -1)\n      ) {\n        const missing = requiredKeys.filter(\n          (req) => valueKeys.indexOf(req) === -1,\n        )\n        if (missing.length === 1) {\n          warn(`shape - required property \"${missing[0]}\" is not defined.`)\n        } else {\n          warn(\n            `shape - required properties \"${missing.join(\n              '\", \"',\n            )}\" are not defined.`,\n          )\n        }\n\n        return false\n      }\n\n      return valueKeys.every((key) => {\n        if (keys.indexOf(key) === -1) {\n          if ((this as VueTypeLooseShape<T>)._vueTypes_isLoose === true)\n            return true\n          warn(\n            `shape - shape definition does not include a \"${key}\" property. Allowed keys: \"${keys.join(\n              '\", \"',\n            )}\".`,\n          )\n          return false\n        }\n        const type = (obj as any)[key]\n        const valid = validateType(type, value[key], true)\n        if (typeof valid === 'string') {\n          warn(`shape - \"${key}\" property validation error:\\n ${indent(valid)}`)\n        }\n        return valid === true\n      })\n    },\n  }) as VueTypeShape<T>\n\n  Object.defineProperty(type, '_vueTypes_isLoose', {\n    writable: true,\n    value: false,\n  })\n\n  Object.defineProperty(type, 'loose', {\n    get() {\n      this._vueTypes_isLoose = true\n      return this\n    },\n  })\n\n  return type\n}\n","import {\n  toType,\n  toValidableType,\n  validateType,\n  isArray,\n  isVueTypeDef,\n  has,\n  fromType,\n} from './utils'\n\nimport {\n  VueTypesDefaults,\n  ExtendProps,\n  VueTypeDef,\n  VueTypeValidableDef,\n  VueTypeShape,\n  VueTypeLooseShape,\n} from './types'\nimport { typeDefaults } from './sensibles'\nimport { PropOptions } from './types'\n\nimport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n} from './validators/native'\nimport custom from './validators/custom'\nimport oneOf from './validators/oneof'\nimport oneOfType from './validators/oneoftype'\nimport arrayOf from './validators/arrayof'\nimport instanceOf from './validators/instanceof'\nimport objectOf from './validators/objectof'\nimport shape from './validators/shape'\n\nclass BaseVueTypes {\n  static defaults: Partial<VueTypesDefaults> = {}\n\n  static sensibleDefaults: Partial<VueTypesDefaults> | boolean\n\n  static get any() {\n    return any()\n  }\n  static get func() {\n    return func().def(this.defaults.func)\n  }\n  static get bool() {\n    return bool().def(this.defaults.bool)\n  }\n  static get string() {\n    return string().def(this.defaults.string)\n  }\n  static get number() {\n    return number().def(this.defaults.number)\n  }\n  static get array() {\n    return array().def(this.defaults.array)\n  }\n  static get object() {\n    return object().def(this.defaults.object)\n  }\n  static get integer() {\n    return integer().def(this.defaults.integer)\n  }\n  static get symbol() {\n    return symbol()\n  }\n\n  static readonly custom = custom\n  static readonly oneOf = oneOf\n  static readonly instanceOf = instanceOf\n  static readonly oneOfType = oneOfType\n  static readonly arrayOf = arrayOf\n  static readonly objectOf = objectOf\n  static readonly shape = shape\n\n  static extend<T>(props: ExtendProps | ExtendProps[]): T {\n    if (isArray(props)) {\n      props.forEach((p) => this.extend(p))\n      return this as any\n    }\n\n    const { name, validate = false, getter = false, ...opts } = props\n\n    if (has(this, name as any)) {\n      throw new TypeError(`[VueTypes error]: Type \"${name}\" already defined`)\n    }\n\n    const { type } = opts\n    if (isVueTypeDef(type)) {\n      // we are using as base type a vue-type object\n\n      // detach the original type\n      // we are going to inherit the parent data.\n      delete opts.type\n\n      if (getter) {\n        return Object.defineProperty(this, name, {\n          get: () => fromType(name, type, opts as Omit<ExtendProps, 'type'>),\n        })\n      }\n      return Object.defineProperty(this, name, {\n        value(...args: unknown[]) {\n          const t = fromType(name, type, opts as Omit<ExtendProps, 'type'>)\n          if (t.validator) {\n            t.validator = t.validator.bind(t, ...args)\n          }\n          return t\n        },\n      })\n    }\n\n    let descriptor: PropertyDescriptor\n    if (getter) {\n      descriptor = {\n        get() {\n          const typeOptions = Object.assign({}, opts as PropOptions<T>)\n          if (validate) {\n            return toValidableType<T>(name, typeOptions)\n          }\n          return toType<T>(name, typeOptions)\n        },\n        enumerable: true,\n      }\n    } else {\n      descriptor = {\n        value(...args: T[]) {\n          const typeOptions = Object.assign({}, opts as PropOptions<T>)\n          let ret: VueTypeDef<T>\n          if (validate) {\n            ret = toValidableType<T>(name, typeOptions)\n          } else {\n            ret = toType<T>(name, typeOptions)\n          }\n\n          if (typeOptions.validator) {\n            ret.validator = typeOptions.validator.bind(ret, ...args)\n          }\n          return ret\n        },\n        enumerable: true,\n      }\n    }\n\n    return Object.defineProperty(this, name, descriptor)\n  }\n\n  static utils = {\n    validate<T, U>(value: T, type: U) {\n      return validateType<U, T>(type, value, true) === true\n    },\n    toType<T = unknown>(\n      name: string,\n      obj: PropOptions<T>,\n      validable = false,\n    ): VueTypeDef<T> | VueTypeValidableDef<T> {\n      return validable ? toValidableType<T>(name, obj) : toType<T>(name, obj)\n    },\n  }\n}\n\nfunction createTypes(defs: Partial<VueTypesDefaults> = typeDefaults()) {\n  return class extends BaseVueTypes {\n    static defaults: Partial<VueTypesDefaults> = { ...defs }\n\n    static get sensibleDefaults() {\n      return { ...this.defaults }\n    }\n\n    static set sensibleDefaults(v: boolean | Partial<VueTypesDefaults>) {\n      if (v === false) {\n        this.defaults = {}\n        return\n      }\n      if (v === true) {\n        this.defaults = { ...defs }\n        return\n      }\n      this.defaults = { ...v }\n    }\n  }\n}\n\nexport default class VueTypes extends createTypes() {}\n\nexport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n  custom,\n  oneOf,\n  oneOfType,\n  arrayOf,\n  instanceOf,\n  objectOf,\n  shape,\n  createTypes,\n  toType,\n  toValidableType,\n  validateType,\n  fromType,\n}\n\nexport type VueTypesInterface = ReturnType<typeof createTypes>\nexport { VueTypeDef, VueTypeValidableDef, VueTypeShape, VueTypeLooseShape }\n","import { VueTypesDefaults } from './types'\n\nexport const typeDefaults = (): VueTypesDefaults => ({\n  func: () => undefined,\n  bool: true,\n  string: '',\n  number: 0,\n  array: () => [],\n  object: () => ({}),\n  integer: 0,\n})\n"]},"metadata":{},"sourceType":"module"}